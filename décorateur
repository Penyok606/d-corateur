Завдання
Об'єкт, який передбачається використовувати, виконує основні функції. Проте може виникнути потреба додати до нього деяку додаткову функціональність, яка виконуватиметься до і/або після основної функціональності об'єкта.

Спосіб вирішення
Декоратор передбачає розширення функціональності об'єкта без визначення підкласів.

Переваги
Декоратори забезпечують гнучку альтернативу підкласу для розширення функціональності
Декоратори дозволяють модифікувати поведінку під час виконання, а не повертатися до існуючого коду та вносити зміни
Декоратори - це хороше рішення для перестановки завдань, тому що ви можете загорнути компонент з будь-якою кількістю декораторів
Шаблон декоратора підтримує принцип, що класи повинні бути відкриті для розширення, але закриті для модифікації
Недоліки
Декоратори можуть призвести до багатьох невеликих об'єктів у нашому дизайні, і надмірне використання може бути складним
Декоратори можуть викликати проблеми, якщо клієнт сильно залежить від компонентів конкретного типу
Декоратори можуть ускладнити процес аналізу компонента, оскільки вам потрібно не лише інвентувати компонент, але і обернути його кількома декораторами
Може бути складно, щоб декоратори відслідковували інших декораторів, тому що повертатися назад до декількох шарів ланцюга декораторів починає натискати шаблон декоратора поза його справжнім наміром

#include <iostream>

using namespace std;

//абстрактний клас - основа патерну
//декорації підлягає метод do_it()
struct I
{
	virtual ~I() {}
	virtual void do_it() = 0;
};
//"справжній" клас - його метод do_it() мав працювати безумовно
struct A : public I
{
	~A()
	{
		cout << "A dtor" << '\n';
	}
	virtual void do_it()
	{
		cout << 'A';
	}
};
//ще один абстрактний клас - основа майбутніх декорацій-обгорток
class D : public I
{
private:
	I* m_wrappee;
public:
	//декоратор приховує всередині обгорнутий "справжній" об'єкт
	//і перенаправляє йому запити щось зробити
	D(I* inner) : m_wrappee(inner) {}
	~D()
	{
		delete m_wrappee;
	}
	virtual void do_it()
	{
		m_wrappee->do_it();
	}
};
// конкретні реалізації обгорток: спочатку працює вкладений об'єкт, потім - обгортка
struct X : public D
{
	X(I* core) : D(core) {}
	~X()
	{
		cout << "X dtor" << " ";
	}
	virtual void do_it()
	{
		D::do_it();
		cout << 'X';
	}
};
struct Y : public D 
{  
	Y(I* core) : D(core) {}
	~Y()
	{
		cout << "Y dtor" << " ";
	}
	virtual void do_it()
	{
		D::do_it();
		cout << 'Y';
	}
};
struct Z : public D 
{ 
	Z(I* core) : D(core) {}
	~Z()
	{
		cout << "Z dtor" << " ";
	}
	virtual void do_it()
	{
		D::do_it();
		cout << 'Z';
	}
};
void main()
{
	I* anXYZ = new Z(new Y(new X(new A)));
	anXYZ->do_it(); cout << '\n'; // A X Y Z
	delete anXYZ;
	A a;
	I* anX = new X(&a);
	anX->do_it(); cout << '\n'; // A X
}
